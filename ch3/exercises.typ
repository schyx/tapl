#import "@preview/curryst:0.6.0": rule, prooftree, rule-set

= Untyped Arithmetic Expressions

== 3.2.4

#let s2total = 3 + 9 + 27

$S_0$ has 0 elements. $S_1$ has 3 elements. $S_2$ has 3 for the constants, 9 for the first union, and 27 for the third
for a total of 39. $S_3$ has 3 for the constants, 117 for the first union and 59319 for the second union, for a total of
size of 59439.

== 3.2.5

We induct on $i$. For the base case $i = 0$, it is trivial that $nothing subset.eq S_1$.

Say that we have shown $S_(n - 1) subset.eq S_n$. We know that the constants must be elements of $S_(n+1)$, and every
other element of $S_n$ must be generated by one of the two unions using elements from $S_(n-1)$. However, the inductive
hypothesis and the definition of $S_(n+1)$ imply that $S_(n+1)$ contains at least the elements generated using elements
from $S_(n-1)$ in the form of the two unions as well, allowing us to conclude that $S_n subset.eq S_(n+1)$ as desired.

== 3.3.4

=== Induction on Depth

We completely induct on the depth of $s$. If the depth is $1$, then we can apply the _induction on depth_ hypothesis: the
premise is vacuously true as there are no terms with depth less than 1, so $P(s)$.

Next, say that the depth of $s$ is $n$, and we have shown $P(r)$ for all terms $r$ with depth less than $n$. Then, the
_induction on depth_ hypothesis immediately implies that $P(s)$ holds.

=== Induction on Size

This can be proven similarly to _induction on depth_, so it is omitted.

=== Structural Induction

We completely induct on the size of $s$. If $s$ has size 1, then it has no subterms, so $P(s)$ vacuously holds from the
_structural induction_ hypothesis.

Assume that we have shown that for all terms $r$ with size less than $n$, given the _structural induction_ hypothesis,
$P(r)$ holds. We now show that for all terms $s$ with size $n$, $P(s)$ holds. If $s$ has size 1, then the previous
paragraph proves correctness, so we can assume $s$ has size greater than 1. Then by definition of size, $s$ must either
be function applied to a subterm $r$ with $s i z e(r) + 1 = s i z e(s)$, or $s$ must be an if-then-else ternary with
immediate subterms $r_1, r_2, r_3$ such that the sizes of $r_1, r_2, r_3$ are all less than the size of $s$.
- In the first case, since $r$ has size less than $s$, our induction hypothesis shows that $P(r)$ holds, and the
  _structural induction_ hypothesis implies $P(s)$ since $r$ is the only subterm of $s$.
- In the second case, $P(r_1), P(r_2), P(r_3)$ all hold due to our induction hypothesis, and $P(s)$ due to $r_1, r_2,
  r_3$ being the immediate subterms.

== 3.5.5

The explicit induction principle used is:

If we have the claim that $P(C)$ holding for all subderivations $C$ of $D$ implies $P(D)$, then $P(D)$ holds for all
derivations $D$.

== 3.5.10

The inference rules are as follows:

#let inclusion = rule(
  $t arrow.r t'$,
  $t attach(arrow.r, tr: *) t'$
)

#let transitivity = rule(
  $t arrow.r t'$,
  $t' arrow.r t''$,
  $t arrow.r t''$
)

$ #prooftree(inclusion) \ \
  t attach(arrow.r, tr: *) t \ \
  #prooftree(transitivity) $

== 3.5.13

+ + Theorem 3.5.4 does not hold anymore, as $mono("if true then true else false")$ can be evaluated with
    #smallcaps[E-IfTrue] to $mono("true")$ and #smallcaps[E-Funny1] to $mono("false")$.
  + Theorem 3.5.7 is still true, as $mono("true")$ and $mono("false")$ are not given new evaluation rules.
  + Theorem 3.5.8 is still true, as we are not removing any rules, so every term that is not in normal form can still be
    evaluated.
  + Theorem 3.5.11 does not hold anymore via the same example as 3.5.4.
  + Theorem 3.5.12 still holds using the same proof.

+ + Theorem 3.5.4 does not hold anymore. Take for example $mono("if true then if true then true else true else false")$.
    It can be evaluated with #smallcaps[E-IfTrue] to $mono("if true then true else true")$ and with #smallcaps[E-Funny2]
    to $mono("if true then true else false")$.
  + Theorem 3.5.7 is still true, as $mono("true")$ and $mono("false")$ are not given new evaluation rules.
  + Theorem 3.5.8 is still true, as we are not removing any rules, so every term that is not in normal form can still be
    evaluated.
  + Theorem 3.5.11 still holds, though the proof needs to be updated to accomodate the fact that the evaluation rules
    are now nondeterministic.
  + Theorem 3.5.12 still holds using the same proof.

== 3.5.14

We again induct on the on the derivation of $mono(t arrow.r t')$. Note that the conclusion of all the rules from theorem
3.5.4 dealt with the if-then-else ternary, and none of the rules here do, so we build off the correctness of 3.5.4 and
only show the correctness of the new evaluation rules. Note that for each form, we can apply at most one rule. Thus, we
show the correctness for every new rule with casework:

- If the last rule in the derivation was #smallcaps[E-Succ], then $mono("t")$ must be of the form $mono("succ" t_1)$.
  Only one possible derivation rule applies here, and due to the induction hypothesis, $mono(t_1)$ has a unqiue
  subderivation to $mono(t_1')$, so $mono("succ" t_1)$ can only derive to one other term.
- If the last rule in the derivation were #smallcaps[E-PredZero], the output of the rule is fixed, so the output of the
  derivation is unique.
- Similar logic as the previous bullet for #smallcaps[E-PredSucc].
- If the last rule in the derivation was #smallcaps[E-Pred], then $mono(t)$ must be of the form $mono("pred" t_1)$. Then
  the two possible derivations are of the form $mono("pred" t_1')$ and $mono("pred" t_1'')$ such that $mono(t_1 arrow.r
  t_1')$ and $mono(t_1 arrow.r t_1'')$. By the induction hypothesis, $mono(t_1' = t_1'')$, so the two derivations of $t$
  must be the same as well.
- Uniqueness of the derivation of #smallcaps[E-IszeroZero] can be proven the same way as #smallcaps[E-PredZero].
- Uniqueness of the derivation of #smallcaps[E-IszeroSucc] can be proven the same way as #smallcaps[E-PredSucc].
- Uniqueness of the derivation of #smallcaps[E-Iszero] can be proven the same way as #smallcaps[E-Pred].

== 3.5.16

We show that the two formalisms are equivalent by showing that the system is will converge to a "stuck state" in the
first formalism if and only if it will output $mono("wrong")$ in the second state. Note that the new rules with
$mono("wrong")$ are still deterministic, as at each step, there is only one possible rule to apply.

For the forward direction, we structurally induct on a system that is in a "stuck state". Note that a value cannot be in
a stuck state by definition. Thus, we only need to consider the following four cases:

- If the system is in an if-then-else ternary and in a stuck state, then the guard is either a numeric value or is in a
  stuck state itself. In the first case, #smallcaps[E-If-Wrong] immediately leads to $mono("wrong")$. In the second
  case, the structural induction hypothesis reduces our guard to $mono("wrong")$, and we can again apply
  #smallcaps[E-If-Wrong] to get $mono("wrong")$.
- Otherwise the system is in a $mono("succ")$, $mono("pred")$, or $mono("iszero")$ function call and in a stuck state.
  In this case, the argument of the function is either a boolean or itself in a stuck state. In the former case, we can
  apply the appropriate #smallcaps[E-...-Wrong] rule to reduce our system to $mono("wrong")$. In the latter, the
  structural induction hypothesis tells us that our argument evaluates to $mono("wrong")$ and we can again apply the
  appropriate evaluation rule to show our total system evaluates to $mono("wrong")$ as well.

For the backward direction, assume that a system will never converge to a stuck state. Then, by theorem 3.5.12, we will
eventually reach a normal form, and by definition, every normal form that is not a stuck state will be a value in the
first formalism. Thus in the second formalism, we will follow the same chain of rules (due to our rules leading to
unique derivations) and wind up at a non-$mono("wrong")$ value as well.

== 3.5.17

For the forward direction, we structurally induct on $t$.

- If $mono(t)$ is already a value $mono(v)$, then $mono(v attach(arrow.r, tr: *) v)$ by taking 0 steps, and $mono(v
  arrow.b.double v)$ by #smallcaps[B-Value].
- If the term is an if-then-else ternary, then we do casework on the guard $mono(t_1)$.
  - If $mono(t_1 = "true")$, then the rule #smallcaps[E-IfTrue] shows that our term evaluates to $mono(t_2)$. By the
    induction hypothesis, this this means that the whole term evaluates to $mono(v_2)$ such that $mono(t_2
    arrow.b.double v_2)$. However, #smallcaps[B-IfTrue] implies the same thing for our larger expression.
  - Similar logic as the previous bullet can be applied if $mono(t_1 = "false")$.
  - Otherwise $mono(t_1)$ is not in normal form. However, our induction hypothesis tells us that continually evaluating
    $mono(t)$ will convert the guard into the value that agrees with the _big-step_ semantic value. Then, we can apply
    one of the two previous bullets based on the value of the guard.
- If the term is otherwise a $mono("succ")$, $mono("pred")$, or $mono("iszero")$ function call, our structural induction
  hypothesis tells us that continually evaluating with _small-step_ semantics will leave the argument as a value that
  agrees with the _big-step_ semantics evaluation of the argument. Then, because the rules of _big-step_ semantics agree
  with the rules of _small-step_ semantics when the arguments of these functions are values, we conclude that the final
  evaluation in the two systems agree.

For the backward direction, we again structurally induct on $mono(t)$.

- If $mono(t)$ is a value, then again applying #smallcaps[B-Value] and taking no steps in _small-step_ semantics leave
  us with the same value.
- If $mono(t)$ is the if-then-else ternary, our induction hypothesis tells us that the guard will end up as the same
  value. Then, applying the appropriate pair of evaluation rules in each of our semantics shows us that the same case
  will be evaluated, and our induction hypothesis again guarantees their agreement.
- If $mono(t)$ is a function call, our induction hypothesis implies that the arguments of the functions will end up as
  the same value, and since the evaluation rules agree with each other when the argument of the function is a value, we
  again have agreement.

== 3.5.18

We replace the three rules governing the if-then-else ternary with the following:

#let thenCase = rule(
  $mono(t_2 arrow.r t'_2)$,
  $mono("if " t_1 " then " t_2 " else " t_3 arrow.r "if " t_1 " then " t'_2 " else " t_3)$
)

#let elseCase = rule(
  $mono(t_3 arrow.r t'_3)$,
  $mono("if " t_1 " then " v_2 " else " t_3 arrow.r "if " t_1 " then " v_2 " else " t'_3)$
)

#let guardEval = rule(
  $mono(t_1 arrow.r t'_1)$,
  $mono("if " t_1 " then " v_2 " else " v_3 arrow.r "if " t'_1 " then " v_2 " else " v_3)$
)

$ #prooftree(thenCase) \ \
  #prooftree(elseCase) \ \
  #prooftree(guardEval) \ \
  mono("if true then " v_2 " else " v_3 arrow.r v_2) \ \
  mono("if false then " v_2 " else " v_3 arrow.r v_3)
$
